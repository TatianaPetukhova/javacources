update
Java questionary
старайтесь давать развёрнутые ответы.
ФИО

Укажите Ваши фамилию, имя и отчество 
 
----Какова разница между абстрактным классом и интерфейсом?
Абстрактным класс, это класс с модификатором abstract, мы не может создавать его  экземпляры, он может содержать абстрактные методы, без реализации. Класс хоть с одним абстрактным методом должен быть объявлен абстрактным. Методы в абстрактном классе могут иметь разные модификаторы доступа.
Интерфейс это структура, в которой методы могут фигурировать только как абстрактные public и поля как константы (final static). На основе интерфейса тоже нельзя порождать объекты. Но класс может наследоваться от одного класса максимум, абстрактного в том числе, но от нескольких сразу интерфейсов.


----Как «насильно» вызвать сборку мусора?
сборщик мусора это процесс очистки памяти, который очищает пямать от объектов, на которые уже нет ссылок в программе, выполняется в демоническом потоке.его можно вызвать методами System.gc() или Runtime.getRuntime().gc(). Но использование этих методов не гарантирует, что удаление объектов произойдет. garbage collector только заносит объекты в специальный список, помеченных для удаления.
 
 
----Когда требуется явное приведение классов?
Приведение классов\типов бывает двух типов - восходящее и нисходящее. Восходящее преобразовывает тип потомка к родительскому типу, т.е. типу который стоит в иерархии выше. Нисходящее - наоборот.
То есть если объект класса-родителя присваивается переменной класса-потомка, в таком случае нужно указать явно в скобках тип подкласса. Например, если B это потомок A, то нужно написать B b = (B) a.



---- Чем конструкторы отличаются от других методов?
в отличие от методов конструкторы создают экземпляры класса, их имя совпадает с именем класса. Конструктор класса внутри первой строчкой, даже если не указано явно, выполняет обращение к конструктору супер-класса через super(), либо можно явно указать первой строкой общарение к конструктору супер класса с параметрами, или этого же класса через this()с какими-то параметрами. У конструктора нет типа возвращаемого значения, а модификатор может быть только из тех, что указывают на область видимости, как private, default, protected, public. Таким образом, у обычных методов более широкое назначение.


 
----Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Да, мы можем в классе перегрузить конструкторы, например, создать один конструктор без параметров First(), другой конструктор с параметрами First (int z), и написать в теле первого конструктора в первой строке явное обращение к конструктору с параметром как 
First() {
this(0);
}

 
------В чем разница между JDK и JRE?
JRE (java runtime enviroment) это набор Java библиотек и JVM (виртуальная машина Java, которая интерпретирует байт-код). JRE это тот минимальный набор, который позволяет запускать на машине пользователя приложения, написанные на Java.
JDK (Java development kit) это болле общее понятие, оно содержит в себе JRE, т.е. JVM и стандартные библиотеки, кроме того разные утилиты, которые необходимы разработчику, такие как компилятор javac, средство для работы с документацией javadoc, jar архиватор, средство для работы с апплетами appletviewer и тд. 


 
----- Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
Ислючение это грубо говоря некоторой ошибка, которая возникла в работе программы. Исключение в java это тоже объект, и типы исключений имеют свою иерархию.
В самом верху этой иерархии (если не считать класс Object) находится класс Throwable. Кроме того в этой структуре исключение FileNotFoundException  находится ниже чем IOExceptipon (исключение, связанное с ошибкой ввода-вывода), т.е. первое - более узкое. Это значит, что когда мы используем в блоке try-catch несколько catch, отлавливая исключительные ситуации, то если мы сначала укажем исключение IOExceptipon, то более узкое исключение типа FileNotFoundException в нем будет поймано, до второго блока catch мы так и не дойдем. Соответственно мы не получим более детальную инфорамацию о типе исключения, что не есть хорошо. Поэтому в блоке try-catch лучше в первом catch указать более специфичную ошибку FileNotFoundException, во втором catch более общую IOExceptipon. В случае если выброшенное исключение не принадлежит первому типу, программа перейдет ко второму catch.


 ----- Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?


 
 
 
 
 
------ Как подкласс может обратиться к методу или конструктору из суперкласса?
Если один класс наследуюется от другого, то в конструкторе класса-наследника есть неявное обращение к конструктору родителя в первой строке, если не указано явно, указывать явно нужно тоже в первйо строке. Так же можно вызвать метод родительского класса через ссылку super.methodName(), super здесь ссылается на суперкласс. Используется в том случае, когда родительский класс содержит метод с таким же именем как данный его подкласс.

 
-------В чем разница между очередью и стеком?
Очередь (queue) и стек (stack) - это коллекции, которые позволяют хранить и манипулировать данными. Эти коллекции различаются своей реализацией. Очередь реализует так называемую концепцию "первый зашел - первый вышел" (fifo). Добавление элемента методом add происходит в конец очереди, удаление элемента методом remove в начале очереди. Стек реализует концепцию "последний зашел - первый вышел" (Lifo), ее удобно представлять как стопку тарелок. У нее есть несколько основных методов: push() - добавить элемент, добавляется в конец (верх) стека, pop() - извлекается элемент с конца стека, peak() - просматривается элемент в конце стека без его удаления.


 
----- Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?

 
------Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?



 
------ Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
в Java есть четыре модификатора доступа для класса: public - класс будет доступным отовсюду, protected - доступен наследникам, private - защищенный,доступ только внутри этого класса, default (если не указан явно) - доступ внутри этого пакета. Соответственно для доступа из того же пакета нужно использовать последний default (его еще называют friendly) модификатор, т.е. явно его не указывать.


 
------Чем отличается статический внутренний класс от просто внутреннего класса?
Оба описываются внутри класса, но статический внутренний класс имеет модификатор static, просто внутренний нет. Для создания экземпляра статического внутреннего класса не нужен экземпляр внешнего класса, достаточно создать его через new OuterClass.InnerClass(); для создания экземпляра просто внутреннего класса нужен конкретный экземпляр внешнего класса, например, для создания использовать outerClass.new InnerClass(), где outerClass -экземпляр внешнего класса, в котором находится внутренний класс, этот класс может обращаться к элементам класса, от которого он порожден.

 
-----можно ли обратиться к не-статической переменной из статического метода?
статическое поле в классе, это поле общее для всего класса, т.е. для всех экземпляров этого класса. Статический метод - это метод в классе, который работает без конкретного экземпляра класса, его можно вызвать через ClassName.methodName. Не-статические переменные для класса создаются свои для каждого экземпляра, таким образом, из статического метода нельзя обратиться к не-статической переменной, т.к. мы обращаемся не имея конкретный экземпляр класса, у нас нет неявной ссылки на экземпляр класса this. В некоторых специфичных случаях, если мы передадим, например, в статический метод в качестве параметра экземпляр класса, то есть будем иметь конкретный экземпляр класса в статическом методе, тогда мы сможем через ссылку на этот экземпляр обратиться к его нестатическому полю.

 
-----какие типы данных есть в Java?
В Java есть примитивные типы данных и ссылочные. Примитивные типы данных - это boolean (значения true, false), символьные char, целочисленные byte, short, int, long (память в два раза растет от byte - 8 бит, до long - 64 бит); числовые с плавающей точкой - это float и double (используются для вещественных, 32 бит и 64). Примитивные типы данных не являются объектами, но для них есть специальные классы-обертки, например Character, Integer и т.д., которые создают объекты на основе примитивных.
Ссылочные типы данных включают более сложные конструкции, например, String (неизменяемый ссылочный тип), массивы -для хранения проиндексированных объектов одного типа, классы и интерфейсы - тоже ссылочные типы данных. Ссылки на такие объекты хранятся в памяти в стеке, а сами объекты в куче, таким образом под именем переменной хранится ссылка на объект, а не сам объект.


------Чем отличаются переопределение (Override) и перегрузка (Overload)
Переопределение методов используется в классах-потомках для модификации поведения объектов;мы можем переопределить метод, который присутствует в родительском классе, использую то же имя и ту же сигнатуру, что были в родительском. Либо мы реализовываем метод, который был в потомке - абстрактном классе, или интерфейсе. Перед обращением к методу нужно поставить аннотацию @override.
Перегрузка методов - это использование одного и того же имени метода, но с разной сигнатурой,т.е набором параметров (числом\типом).


-------Что такое итератор?
это объект, реализующий специальный паттерн, который позволяет пробегать по элементам коллекции (есть также интерфей Iterator<T> ). У него есть методы boolean hasNext(), который сообщает есть ли следующий элемент в коллекции, и метод next(), который возвращает следующий элемент и передвигает итератор на один элемент.Это более гибкая замена for each, так как позволяет удалять элементы.

 
-----Перечислите основные категории исключительных ситуаций
Эксепшены или исключительные ситуации это объекты, сообщающие об ошибке в программе. Все они являются потомками класса Throwable, от него наследуются два класса Exception и Error, от Exception наследуется Runtime exception.
Error и RuntimeException и все их наследники — непроверяемые исключения, это те ошибки, которые могут возникнуть почти в любой программе и явно их указывать везде, это слишком рутинно. К ним относятся например NullPointerException. Есть также проверяемые исключения, которые должны быть явно обработаны в коде, используя try-catch блоки, так же метод, который может выбросить исключение нужно помечать через имя_метода throws класс_экспешена.


----- Какая разница между throw и throws?
throw -  это зарезервированное слово, которое сообщает, что в данном месте программа выбрасывает исключительную ситуацию, throw new Exception_name(). Exception_name обладает типом Throwable. 
throws ставится в заголовке метода после его имени, например, methodName throws Exception_name, эта структура показывает, что метод может породить исключение (не нужно здесь указывать непроверяемые исключения).

 
Зачем нужен блок finally?
это блок, выполняемый после try-catch (даже если нет catch). он выполняется в любом случае, возникнет исключение или нет. Необходим для более корректного завершения работы с какими-то ресурсами или данными, в случае эксепшена.
 
 
-------Что такое finalize?
это метод который есть в классе Object, он выполняется сборщиком мусора, когда он удаляет объект из памяти. Если нужно что-то сделать конкретное перед удалением объекта, то можно переопределить этот метод в классе. С этим методом нужно быть аккуратней и по возможности избегать его использование.
 
 
---- Перечислите все виды внутренних классов
Внутренние классы бывают 4х типов: анонимные, которые создаются сразу в месте описания без имени, локальный класс - описывается в методе или блоке инициализатора класса, внутренний класс - класс который описывает внутри класса, вложенный - статический внутренний класс.
